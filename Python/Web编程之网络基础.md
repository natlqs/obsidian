## - TCP/IP网络

- TCP/IP是Transmission Control Protocol/Internet Protocol的简写，翻译成中文为传输控制协议/互联网络协议。TCP/IP是一种网络通信协议，它规范了网络上的所有通信设备，尤其是一个主机与另一个主机之间的数据往来格式及传送方式。TCP/IP是Internet的基础协议，也是一种计算机数据打包和寻址的标准方法。
### - 网络设备

#### - 集线器 Hub

- **接口层设备**。集线器是网络互连的最简单设备，它接收并识别网络信号，然后再生信号并将其发送到网络的其他分支上。

#### - 交换机 Switcher

- 即Switcher，是**接口层设备**，也是网络互联中最常用的设备。它与集线器的差别是HUB本身不能识别目的地址，而交换机可以。当同一局域网内的A主机向B主机传输数据时，数据包在经过HUB时在网络上是以广播方式传输的，由每一台终端通过地址信息来确定数据包是否属于自己；数据包经过Switcher时，Switcher会根据Frame目的地址直接发送给B主机所在的链路。因此，在网络中用交换机替换集线器通常能提高网络的整体性能。

#### - 网桥 Bridge

- **接口层设备**。通常用于物理异构的为网络之间相互连接。

#### - 路由器 Router

- **网络层设备**。路由器是互联网的主要结点设备，通过发送者、接收者的IP地址和路由算法决定数据的收发路径，这一过程叫作Routing。

#### - 网关 Gateway

- 一般为应用层设备，主要指不同网络环境之间的协议转换。比如一个专用于数据存储转发的服务器。

#### - 调制解调器 Modem

- **接口层设备**，用于连接计算机网络与传统通信网。Modem将计算机的数字信号转译成能够在常规电话线中传递的模拟信号。因为模拟信道的传输距离更长，所以长距离的网络传输一般都需要经过Modem转接。

#### - 无线接入点 Wireless Access Point

- **接口层设备**。将有线网络转为无线网络，最常用的无线接入点即WiFi。

#### - 防火墙 Firewall

- **传输层及应用层的设备**。防火墙通常位于不同网络的边界处，主要用于防止恶意程序及数据内部网络，或者防止机密信息泄露到广域网中，企业级网络通常用防火墙低于非法入侵。

#### - IP地址

- 网络地址（Network Address）是一个网络层概念，是互联网上的主机在网络中具有的逻辑地址。Internet上采用IP地址表示网络地址。当前有两种形式的IP地址，即IPv4和IPv6。
- IPv4诞生于1982年，随着TCP/IP的发展壮大，缔造了当今的计算机网络通信模式。IP地址是一个32位二进制数的地址，在表达方式上以4个十进制数字表示，比如172.16.32.3、10.38.96.243等。从理论上讲，有大约60亿（232）种可能的地址组合，这似乎是一个很大的地址空间。实际上，一个IPv4地址被划分为两部分：网络地址和主机地址。根据网络地址和主机地址的不同位数规则，可以将IP地址分为A（8位网络ID和24位主机ID）、B（16位网络ID和16位主机ID）、C（24位网络ID和8位主机ID）3类，由于历史原因和技术发展的差异，A类地址和B类地址几乎分配殆尽。
    
    由于IPv4的数量限制，IPv6应运而生。IPv6由128位二进制数组成，在表达方式上用8个16进制数字表示，比如d23:4334:0:0:23:ade:9853:23。单从数量级上来说，IPv6所拥有的地址容量约是IPv4的8×1028倍，达到2128个。这不但解决了网络地址资源数量的问题，也为除计算机外的设备连入互联网在数量限制上扫清了障碍。然而让人遗憾的是，IPv6自1999年开始分配以来，并没有在互联网上得到广泛应用。目前互联网的主要地址表达方式及其调制仍主要以IPv4为主，但IPv6必将会替代IPv4。  
    
- ifconfig和ping命令

|命令名|说明|
    |---|---|
    |ifconfig|查看网卡信息|
    |ping|检查网络是否正常|
#### - 域名

- 由于IP地址由纯数字组成，很难让人记忆，且不能表达功能、地理位置等附加含义，所以在TCP/IP网络形成不久，标准化组织就定义了域名这种主机地址表达方式。
    
    域名（Domain Name）是一个应用层概念，是由一串用点分隔的名字组成的Internet上某台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位（有时也指地理位置、地理上的域名或有行政自主权的一个地方区域）。域名是一个IP地址的“面具” 。一个域名是便于人们记忆和沟通的一组服务器的地址（网站、电子邮件、FTP等）。使用域名作为标记互联网计算机的名称已有30多年的历史，世界上第1个域名是在1985年1月被注册的。  
    域名中的标号都由英文字母和数字组成，每个标号不超过63个字符，字母也不区分大小写。标号中除连字符（-）外不能使用其他标点符号。级别最低的域名写在最左边，而级别最高的域名写在最右边。由多个标号组成的完整域名总共不超过255个字符。读者所熟知的域名如www.baidu.com、www.sina.com.cn等。  
    

#### - URL 网址

- 统一资源定位符是用来表示Internet上资源位置的标准。资源位置包括资源所在的主机及其在主机内的访问路径。这里所说的资源是指Internet上任何可访问的对象，包括文本、图像、视频流等。URL的标准形式如下：
    
    其中，协议可以是HTTP、FTP等应用层协议；主机是域名或IP地址；端口是传输层端口号；路径是以“/”分割的主机内的路径；"?"后面的是查询参数，参数是以“&”分割的若干键值对。典型的URL包括http://www.mysite.edu:80/app/search.html?page=1&name=david、ftp://10.45.213.20:21/myfile等。  
    

### - TCP和UDP

- TCP/IP的传输层是网络中承上启下的关键一层，向上对应用层提供通信服务，向下将应用信息封装为网络信息。传输层连接主机之间的进程，同一主机中不同进程的网络通信通过端口进行区分，所以传输层为主机提供的是端口到端口的服务。
#### - 端口

- 这里所说的端口，不是计算机硬件的I/O端口，而是软件级的概念。就像IP地址是网络层的寻址方式一样，端口是传输层的寻址方式。端口是一个16位二进制数表达的正整数，数字范围为0～65535，即一个在网络上通信的主机理论上最多有65535个传输层信道。但由于在操作系统和一些应用中端口也被用作同一主机上不同进程之间的通信，因此通常可用的网络端口数量少于65535个。
- 应用程序（调入内存运行后一般被称为进程）通过系统调用与某端口建立连接（Binding，绑定）后，传输层传给该端口的数据都被相应的进程所接收，相应的进程发给传输层的数据都从该端口输出。由于TCP/IP传输层的TCP和UDP是两个完全独立的软件模块，因此各自的端口号也相互独立。
- TCP和UDP可以在同一主机上使用相同的端口而互不干扰。例如TCP有一个53号端口，UDP也可以有一个53号端口，两者并不冲突。
- 每种网络的服务功能都不相同，因此有必要将不同的封包发送给不同的服务来处理，当主机同时开启了FTP与WWW服务时，网络上发来的数据包就会按照端口号来给予FTP服务或者WWW服务。Internet上的很多标准应用层协议有默认的使用端口号。
- 知名端口号0到1023，这些端口号一般固定分配给一些服务。
- 常用默认端口号
- [[assets/Web编程之网络基础/afbd9fb9d3159fc1ed170dce899491a1_MD5.jpeg|Open: Pasted image 20240220135635.png]]
![[assets/Web编程之网络基础/afbd9fb9d3159fc1ed170dce899491a1_MD5.jpeg]]

#### - TCP

- TCP（传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC793定义。当应用层向TCP层发送用于网间传输的用8位字节表示的数据流时，TCP则把数据流分割成适当长度的报文段，最大传输段大小（MSS）通常受该计算机连接的网络的数据链路层的最大传送单元（MTU）限制。之后TCP把数据包传给IP层，由它通过网络将包传送给接收端实体的TCP层。总结TCP的特性如下。

- · 有序性：为每个数据包编排序号，使接收端能够判断先后到达的次序混乱的数据包的原本顺序。
- · 正确性： TCP用一个checksum函数来检验数据是否有错误，在发送和接收时都要计算校验和，这使得接收端能够判断数据是否在传输过程中被破坏。
- · 可靠性：发送端采用超时重传并有确认机制识别错误或丢失数据，进行重发。
- · 可控性：接收端和发送端的网络质量通常不同，TCP采用滑动窗口协议和拥塞控制算法使数据的发送速度达到合理值。
- TCP采用面向连接的方式收发数据，在收发数据之前需要先建立连接，在数据传输之后释放连接
- [[assets/Web编程之网络基础/ea704ba675292bfd97ed39f5485c8403_MD5.jpeg|Open: Pasted image 20240220135700.png]]
![[assets/Web编程之网络基础/ea704ba675292bfd97ed39f5485c8403_MD5.jpeg]]

- TCP传输模型
- 建立连接的三次握手过程如下。

	- · 建立连接时，客户端发送SYN包到服务器，并进入SYN_SENT状态，等待服务器确认。
	- · 服务器收到SYN包，反馈给客户端一个SYN+ACK包，此时服务器进入SYN_RECV状态。
	- · 客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK，客户端和服务器同时进入ESTABLISHED（TCP连接成功）状态，完成三次握手。
- 建立连接后双方可互相发送消息，消息完成后可由任意一方发起关闭连接请求。关闭连接的过程如下。

	- · 关闭请求方（比如客户端）向另一方发送（比如服务器）一个带有FIN附加标记的报文段。
	- · 服务器收到这个FIN报文段之后，并不立即用FIN报文段回复主机A，而是先向主机A发送一个确认序号ACK，同时通知相应的应用程序：对方要求关闭连接，使应用程序做相应的清理工作。
	- · 服务器的应用程序清理工作完成后，向客户端发送一个FIN报文段。
	- · 客户端收到这个FIN报文段后，向服务器发送一个ACK，表示连接彻底释放。

#### - UDP

- UDP（User Datagram Protocol）是一种无连接的传输层协议，提供面向事务的简单的不可靠信息传送服务，IETF RFC 768是UDP的正式规范。UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小，因此UDP能提供更快速、轻量级的传输层控制。总结UDP的特性如下。

	- · 数据可以随时发送、接收，没有建立、断开连接的过程，因此主机不需要维护复杂的连接状态。
	- · UDP不保证数据的可靠传输，仅仅尽最大可能进行发送。
	- · 没有拥塞控制算法控制收发速率，程序需在应用层自行控制。
	- · 发送方的UDP对应用程序交付的报文，在添加首部后就向下交付给IP层。既不拆分，也不合并。因此，应用程序需要选择合适的报文大小。
- 由此，不难总结出UDP协议适用的应用场景：吞吐量大（因为只做轻量级控制）、可以承受信息丢失（因为传输不可靠）。在网络状况良好的情况下，UDP的丢包率在实际情况下也非常低，所以仍有很多经典协议采用UDP进行传输，比如SNMP、NFS、DNS、BOOTP等。

### - C/S B/S架构

- C/S，即Client/Server，是当前大多数网络编程所使用的架构模型。通过它可以充分利用两端硬件环境的优势，将任务合理分配到Client端和Server端来实现，降低了系统的通信开销。Client和Server常常分别处在相距很远的两台计算机上，Client程序的任务是将用户的要求提交给Server程序，再将Server程序返回的结果以特定的形式显示给用户；Server程序的任务是接收客户程序提出的服务请求，进行相应的处理，再将结果返回给客户程序。
- B/S，即Browser/Server，是Web兴起后的一种网络结构模式。B/S使用Web浏览器作为客户端的应用软件，所以B/S可以看作C/S的一种特殊情况。B/S架构是伴随着因特网的兴起而兴起的，是对C/S结构的一种改进，它的主要特点如下。

	- · 便于部署、维护与升级：主流企业的软件开发流程与方法也从传统瀑布模型转为迭代式敏捷开发。软件系统的改进与升级节奏的加快对系统的快速部署、升级提出了很高的要求。B/S架构的产品明显体现着更为方便的特性，因为B/S系统的所有应用程序都部署在服务器上，而一般无须更新客户端软件（即浏览器）。
	- · 跨平台、开放、对客户端要求低：客户端计算机的软硬件环境千差万别，虽然大多数是Windows系统，但近年来macOS操作系统也越来越普及，另外有少数钟情于Linux的用户。传统C/S架构需要针对每种操作系统开发相应的客户端程序；而因为每种操作系统都支持Web浏览器，所以基于B/S架构的系统只需开发一套客户端程序。B/S架构的客户端程序部署在服务器端，由浏览器在访问时下载到客户端运行。
	- · 对安全性的要求较高：由开放性而延伸的一个负面作用就是B/S架构对系统安全性的要求比C/S架构要高。B/S架构的系统一般建立在广域网上，面向未知用户，所以开发B/S系统时应该更加关注系统的防攻击、数据加密、备份、防伪造等能力。
    
    在本书之后要讲解的Python网络框架中，Django、Tornado和Flask均是以B/S架构为主要开发目标的框架，Twisted主要面向C/S架构系统。

## - HTTP

- >HTTP（Hyper Text Transfer Protocol），即超文本传输协议，是Internet上最主要的Web应用层标准。B/S架构的应用系统用HTTP在客户端与服务器之间传送数据。HTTP可以传送任何格式的数据，从文本到图像甚至视频流都可以通过HTTP进行传输。本节讲解进行网络开发所必需的HTTP知识。

- 超文本：在文本数据的基础上还包括非文本数据，如音乐、图片、视频等，而这些非文本数据会使用链接的方式进行加载显示。通俗来说，超文本就是带有链接的文本数据，也就是我们常说的网页数据。
- 传输HTTP协议格式的数据是基于TCP传输协议的，发送数据之前需要先建立连接。
- TCP传输协议是用来保证网络中传输的数据的安全性的，HTTP协议是用来规定这些数据的具体格式的。

### - HTTP流程

- HTTP是Web浏览器与Web服务器之间通信的标准协议，是Internet上能够可靠地交换文件的重要基础。HTTP的基本交互流程如图
- [[assets/Web编程之网络基础/7a9821d715b986536655af90e495102c_MD5.jpeg|Open: Pasted image 20240220135845.png]]
![[assets/Web编程之网络基础/7a9821d715b986536655af90e495102c_MD5.jpeg]]

#### - HTTP基本交互流程

- 每个HTTP站点都有一个服务器进程监听着TCP的HTTP端口，HTTP端口默认为80，也可由服务器进程设置为其他端口。当服务器发现有客户端建立连接并提交了一个 HTTP 请求（Request）后，就根据请求的内容执行相应的操作，并将结果返回给客户端（Response）。通常客户在浏览器中发起一次网络访问的步骤如下。

	- （1）输入网址并按Enter键，比如访问http://mysite:8080/app/index.html。
	- （2）浏览器通过域名系统查询mysite的真实IP，比如212.34.98.20。
	- （3）向服务器212.34.98.20的8080端口发起TCP连接请求并建立连接。
	- （4）发送HTTP请求的内容，包括访问的地址/app/index.html、访问方式GET、浏览器本身的产品名等。
	- （5）服务器返回/app/index.html中的数据作为Response发送给客户端。如果请求的不是一个文件，则服务器需要执行相应的代码，动态生成且返回给客户端。
	- （6）浏览器接收到结果后关闭与服务器的TCP连接。
	- （7）浏览器将接收到的结果呈现在显示器上。
- > 注意：域名解析本身不是HTTP的一部分，客户端应在向服务器建立TCP连接之前就通过DNS服务器完成域名解析工作。  
    
- 以上是最典型的HTTP流程，当今的HTTP版本还允许客户端在一次HTTP请求完成后不关闭TCP连接，以便第2次发送HTTP请求时复用该连接，从而达到减少系统整体开销的目的，此技术在HTTP中叫作keep-alive。

### - HTTP消息结构

- Python网络开发者必须通过直接或间接的方式与HTTP打交道。通过学习HTTP消息结构，可以让开发人员更好地理解Python Web框架中的各种配置及开发选项。
- Request 消息结构

- HTTP的两种消息（Request和Response）采用不同的消息结构，Request的格式如下：

```
[请求方法][URL][协议版本]
[头字段1]:值1
...
[头字段N]:值N

[消息体]
```

- 结构格式由两部分组成：消息头（HTTP HEAD）、消息体（HTTP BODY）。消息头必须遵循上述格式，头字段可以有若干个；消息体则没有固定格式；HEAD与BODY之间以一个空行分隔。上述格式中的请求方法、URL、协议版本、头字段等都属于消息头。常用的消息体格式包括HTML、XML、JSON等。典型的Request消息如下：

```
GET /hello.txt HTTP/1.1
Host:www.mysite.com
Accept-Language: en
```
- 本例是一个用GET方法访问URL [http://www.mysite.com/hello.txt](http://www.mysite.com/hello.txt) 页面的请求头，向服务器声明使用HTTP1.1版本，并通过Accept-Language标识了客户端接收的消息语言。本例的Request中没有消息体。

### - Response消息结构

- Response是服务器根据客户端的请求包做相应处理后向客户端返回的结果，Response的格式如下：

```
[协议版本][错误码][错误字符串]
[头字段1]:值1
...
[头字段N]:值N

[消息体]
```
- 消息结构仍然由两部分组成，与Request的不同点是第1行由协议版本和错误码组成。典型的Response消息如下：

```
HTTP/1.1 200 OK
Date: Mon, 20 Jul 2015 11:45:34 GMT
Server: Apache
Accept-Range: byges
Content-Length: 31
Content-Type: text/plain

<html>
Hello World.
</html>
```
    
- 本例中返回了一个HTTP 1.1版本的消息，错误代码为200，错误字符串为OK。之后的一系列头字段标识了当前的时间、服务器的应用程序名、消息类型、消息体的长度等。消息体是一个HTML包。

### - 常用头字段

- HTTP头字段以键值对的方式为服务器或客户端提供对方的信息，比如之前用到的Accept-Language、Server等。HTTP中有一些预定义的头字段经常被用到，有经验的开发者需要熟记这些，如表2.2所示。表中的“方向”列，如果是Response则指示从服务器发送给客户端，如果是Request则指示从客户端发送给服务器，Both表示两个方向皆可。
[[assets/Web编程之网络基础/5fbee0ba50725556db05a886d7de95f4_MD5.jpeg|Open: Pasted image 20240220140105.png]]
![[assets/Web编程之网络基础/5fbee0ba50725556db05a886d7de95f4_MD5.jpeg]]

### - 常用错误代码

- 前面已经学习了HTTP，每个Response的第1行中有一个整数状态码用于表达其对应Request的结果。HTTP除了约定了该状态的表达方式，还约定了该状态的取值范围，约定的5类状态码如下。

	- · 1xx：信息；表明服务器已经收到Request，但需要进一步处理，请客户端等待。
	- · 2xx：成功；处理成功。
	- · 3xx：重定向；请求的地址已被重定向，需要客户端重新发起请求。
	- · 4xx：客户端错误；请求中提交的参数或内容有错误。
	- · 5xx：服务器错误；服务器处理请求时出错，一般本类错误需要联系服务器管理员处理。
- > 注意：1xx～5xx的错误为HTTP标准错误，在网站开发中如需定义自己的错误代码，则需要避开该范围。  
    
- 在上述5类错误中，常见的HTTP错误代码如表2.3所示。
[[assets/Web编程之网络基础/df1fdb7154b96390b2b73d2f30c7fb8a_MD5.jpeg|Open: Pasted image 20240220140139.png]]
![[assets/Web编程之网络基础/df1fdb7154b96390b2b73d2f30c7fb8a_MD5.jpeg]]

### - HTTP请求方法

- HTTP Request包的第1个参数“请求方法”，HTTP访问方式的意义在于它能够告诉服务器客户端访问URL的目的是什么，是获取信息、上传数据，还是删除信息等。

[[assets/Web编程之网络基础/c5541c02e676447bcb3141618d460ab7_MD5.jpeg|Open: Pasted image 20240220140149.png]]
![[assets/Web编程之网络基础/c5541c02e676447bcb3141618d460ab7_MD5.jpeg]]

### - 基于HTTP的网站开发

- 经过几十年的发展，已经出现几个成熟的处理HTTP的知名Web服务器。这些Web服务器可以解析（handle）HTTP，当Web服务器接收到一个HTTP请求时，会根据配置的内容返回一个静态HTML页面或者调用某些代码动态生成返回结果。Web服务器把动态响应（dynamic response）产生的委托（delegate）给其他一些程序，例如Python代码、JSP（JavaServer Pages）脚本、Servlets、ASP（Active Server Pages）脚本等。无论它们的目的如何，这些服务器端（server-side）的程序通常会产生一个HTTP响应让浏览器浏览。
- 由于目标操作系统、应用场景及商业目的的不同，当今主流的Web服务器各有特色，将它们的特性简单地概括如下。

	- Apache：是世界上用得最多的Web服务器，市场占有率达**60%**左右。由于其卓越的性能，Tomcat或JBoss等很多其他Web服务器使用Apache为自己提供HTTP接口服务。
	- Nginx：是一款轻量级、高性能的**HTTP和反向代理服务器**。因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。
	- IIS：微软的Web服务器产品。由于Windows的影响，IIS是目前最流行的Web服务器产品之一，它的最大优势当然是对微软ASP.net及其周围产品的支持。
	- Tomcat：是一个开源服务器，是Java Servlet 2.2和JavaServer Pages 1.1技术的标准实现。
	- JBoss：是一个管理EJB的容器和服务器，支持EJB 1.1、EJB 2.0和EJB 3的规范。但JBoss的核心服务不包括支持Servlet、JSP的Web容器，一般与Tomcat或Jetty绑定使用。

- 当前的主流Web服务器都实现了主流语言的可调用接口标准，这些标准如下。

	- CGI：Common Gateway Interface，CGI规范允许Web服务器执行外部程序，并将它们的输出发送给Web浏览器，CGI将Web的一组简单的静态超媒体文档变成一个完整的新的交互式媒体。
	- ISAPI：Internet Server Application Program Interface，是微软提供的一套面向Web服务的API接口，它能实现CGI提供的全部功能，并在此基础上进行了扩展，例如提供了过滤器应用程序的接口。
	- WSGI：Web Server Gateway Interface，是一套专为Python语言制定的网络服务器标准接口。本书将要学习的Python Web框架均以WSGI为基础标准。

- 从客户端浏览器的角度来看，它的每次访问是通过HTTP访问Web服务器从而获得某种服务（下载文件、查看页面、订购商品等）的，但实际上Web服务器仅起到桥梁的作用，即将浏览器的HTTP请求解码，转换成服务器端程序能够识别的接口调用方式，然后将服务器端程序生成的返回封装成HTTP Response，并返回给浏览器。服务器端程序、Web服务器、客户端之间的关系如图

[[assets/Web编程之网络基础/024daebaff0fb42d81432982019bcc1d_MD5.jpeg|Open: Pasted image 20240220140225.png]]
![[assets/Web编程之网络基础/024daebaff0fb42d81432982019bcc1d_MD5.jpeg]]

- 最简单的服务器端程序可以是直接读取某文件或返回固定的网页内容；稍复杂一些的服务器端程序需要处理客户端通过HTTP、URL、HTML中传入的参数、动态执行逻辑代码、在数据库或缓存中读写数据等一系列操作，才能最终生成调用结果。

### - Socket编程

#### - Socket基础

- 是Windows和macOS等其他操作系统所共同遵守的网络编程标准，用于描述IP地址和端口，可以用来实现不同虚拟机或不同计算机之间的通信，当然也可以实现相同主机内的不同进程间的通信。Internet上的主机一般运行了多个服务软件，同时提供几种服务，每种服务都打开一个Socket，并绑定到一个端口上，不同的端口对应不同的服务。
- 在操作系统结构上，Socket为应用程序屏蔽了TCP/IP网络传输层及以下的网络细节，如图2.6所示。Socket为操作系统的用户空间提供网络抽象，开发者编写的网络程序都会直接或间接地用到Socket抽象。通过Socket抽象可以控制传输层协议TCP和UDP，甚至包括部分网络层协议，例如IP和ICMP。
- 除了基于HTTP等标准协议的Web应用，Internet上还有很大一部分应用是基于非公有协议的。无论使用哪种语言进行非标准协议的开发，都需要了解Socket编程的基本知识。本节学习Socket的概念及用Socket进行TCP、UDP开发的方法。
[[assets/Web编程之网络基础/52fc0fd1dc8f0f53183e9506de9544d3_MD5.jpeg|Open: Pasted image 20240220140259.png]]
![[assets/Web编程之网络基础/52fc0fd1dc8f0f53183e9506de9544d3_MD5.jpeg]]
- 应用在使用 TCP 或 UDP 时，会用到操作系统提供的类库。这种类库一般被称为 API（Application Programming Interface，应用编程接口）。 使用 TCP 或 UDP 通讯时，又会广泛使用到套接字（Socket）的 API。套接字原本是由 BSD UNIX 开发的，但是后被移植到了 Windows 的 Winsock 以及嵌入式操作系统中。 应用程序利用套接字，可以设置对端的 IP 地址，端口号，并实现数据的发送与接收。 网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个 Socket。 建立网络通信连接至少要一对端口号(Socket)。Socket 本质是编程接口(API)，对 TCP/IP 的封装，TCP/IP 也要提供可供程序员做网络开发所用的接口，这就是 Socket 编程接口；HTTP 是轿车，提供了封装或者显示数据的具体形式；Socket 是发动机，提供了网络通信的能力。
- Socket使用IP地址+端口+协议的三元组唯一标识一个通信链路。服务器端的一个通信链路可以对应于多个客户端，比如一个Web服务器的80端口可以同时服务大量的客户端。

#### - 实战演练：socket TCP原语

- 用Socket进行网络开发需了解服务器和客户端的Socket原语，每个原语在不同的高级语言中都有相应的实现方式。TCP的Socket原语，如图2.7所示。所有基于TCP的Socket通信都遵循如图2.7所示的流程。下面解释每个原语的含义。
[[assets/Web编程之网络基础/5a48a1d47c4b12e1bb79f56d988eea0f_MD5.jpeg|Open: Pasted image 20240220140314.png]]
![[assets/Web编程之网络基础/5a48a1d47c4b12e1bb79f56d988eea0f_MD5.jpeg]]
- **socket()**：建立Socket对象。Socket是以类似文件系统的“打开、读写、关闭”的模式设计的，socket()原语相当于“打开”。socket()原语的参数通常包括使用的传输层协议类型、网络层地址类型等。
- **bind()**：绑定。在参数中需要传入要绑定的IP地址和端口。IP地址必须是主机上的一个可用的地址（除了用0.0.0.0指定绑定所有的本机IP）。端口必须是一个该Socket协议未被占用的端口，比如当一个主机上的两个程序试图同时绑定到80端口时，只有一个程序能够成功。服务器端程序在listen()之前必须进行bind()操作，而客户端程序如果在connect()原语之前没有调用bind()，则系统会自动为该Socket分配一个未被占用的地址和端口。**技巧**：当主机上存在多个IP地址时，绑定地址0.0.0.0可以监听所有这些可用的IP。
- **linsten()**：监听。只在服务器端有用，告诉操作系统开始监听之前绑定的IP地址和端口，可以在参数中指定允许排队的最大连接数量。
- **connect()**：在客户端连接服务器。参数中需要指定服务器的地址和端口。调用connect()可能有两种结果，即与服务器端完成TCP 3次握手并建立连接或者连接服务器失败。
- **accept()**：接收连接。只在服务器端有用，从监听到的连接中取出一个，并将其包装成一个新的Socket对象。这个新的Socket对象可被用于和相应的客户端进行通信。完成accept()标志着Socket已经完成了TCP链路建立阶段的3次握手。如果当前没有客户端连接请求，则accept()调用会阻塞等待。
- **send()**：发送数据。服务器和客户端均可调用send()向对方发送数据，在send()的参数中传入要发送的数据，通过send()的返回值判断数据是否发送成功。
- **recv()**：接收数据。服务器和客户端均可调用recv()从对方接收数据。如果Socket中没有消息可以读取，则在默认情况下recv()调用会被阻塞直到有消息到达；开发者也可以将Socket设置为非阻塞模式，使recv()以失败形式返回。
- **close()**：关闭连接。通信中的任何一方可以调用close()发起关闭连接请求，另一方收到后也调用close()关闭连接。
```python
# TCP服务器端代码， Socket编程方法
import socket
import datetime
HOST = '0.0.0.0'
PORT  = 3434
# AF_INET说明使用IPv4地址，SOCK_STREAM指明TCP
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind((HOST, PORT))
s.listen(1)
while True:
  conn, addr = s.accept()
  print('Client &s connected!' % str(addr))
  dt = datetime.datetime.now()
  message = 'Current time is ' + str(dt)
  conn.send(message.encode('utf8'))
  print('Sent: ', message)
  conn.close()
```
    
- 包socket封装了所有Python的原生Socket操作，代码中通过socket()、bind()、listen()的一系列调用实现了对指定端口的监听，通过accept()接收客户端的连接，当有客户端连接成功后将当前系统时间发送给客户端，并马上关闭连接。因为代码主体处于while循环中，所以程序将不断监听并一直运行。**注意：**send()函数接收的参数为bytes类型，因此在调用该函数时需要将字符串参数通过.encode(‘utf-8’)方法转换为bytes类型。
```python
# TCP客户端
import socket
HOST = '127.0.0.1'
PORT = 3434
# AF_INET说明使用IPv4地址，SOCK_STREAM指明TCP协议
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((HOST, PORT))
print('Connect %s: %d OK' % (HOST, PORT))
data = s.recv(1024)
print('Received: ', data)
s.close()
```
    
- 客户端通过connect()调用、连接服务器，连接成功后接收从服务器发来的数据，然后关闭连接、退出程序。
- 现在尝试服务器与客户端通信的执行效果，首先启动服务器程序：
[[assets/Web编程之网络基础/11710e39e8b9f750abacb1bfd7436095_MD5.jpeg|Open: Pasted image 20240220140412.png]]
![[assets/Web编程之网络基础/11710e39e8b9f750abacb1bfd7436095_MD5.jpeg]]
- 服务器程序将进入等待连接状态。然后打开另外一个控制台，执行客户端程序如下：
[[assets/Web编程之网络基础/c33087b3bedb0ff24ac2bd90db946b2e_MD5.jpeg|Open: Pasted image 20240220140416.png]]
![[assets/Web编程之网络基础/c33087b3bedb0ff24ac2bd90db946b2e_MD5.jpeg]]
- 从以上输出中已经可以看到服务器发送过来的当前时间，说明已经成功进行通信。同时，服务器窗口中可以看到如下输出结果：
[[assets/Web编程之网络基础/e8811970a76024f79b6f5be3922d0b54_MD5.jpeg|Open: Pasted image 20240220140421.png]]
![[assets/Web编程之网络基础/e8811970a76024f79b6f5be3922d0b54_MD5.jpeg]]

#### - 实战演练：Socket UDP原语

- UDP相对于TCP在传输层提供更少的控制，没有建立连接、断开连接等概念，所以基于UDP的Socket通信过程也比TCP稍微简单。在UDP中可以直接通过指定IP:Port进行数据收发。UDP Socket可以复用TCP中的socket()和bind()原语，除此之外，UDP属于自己的Socket原语如下。
- recvfrom ()：从绑定的地址接收数据。
- sendto ()：向指定的地址发送数据，在调用的参数中应该传入通信对端的地址和端口。
```python
# UDP服务端
import socket
HOST = '0.0.0.0'
PORT = 3434
# AF_INET说明使用IPv4地址，SOCK_DGRAM指明UDP
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
s.bind((HOST, PORT))

while True:
  data, addr = s.recvfrom(1024)
  print('Received: %s from %s ' % (data, str(addr)))
```
    
- 代码通过socket()和bind()调用绑定了本地所有地址的3434端口，通过socket()中的SOCK_DGRAM指定Socket使用UDP，在一个循环中不断地接收数据并打印。相应的UDP客户端的Python代码如下：
```python
# UDP客户端
import socket
HOST='127.0.0.1'
PORT = 3434
# AF_INET说明使用IPv4地址，SOCK_DGRAM指明UDP
s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
data = 'Hello UDP!'
s.sendto(data.encode('utf-8'), (HOST, PORT))
print('Sent: %s to %s:%d' %(data, HOST, PORT))
s.close()
```
- 客户端直接调用sendto()向指定的地址发送数据。与TCP类似，在启动客户端之前同样需要先运行服务器程序：
[[assets/Web编程之网络基础/5262aad33a7b293c43c41e07d6050c76_MD5.jpeg|Open: Pasted image 20240220140510.png]]
![[assets/Web编程之网络基础/5262aad33a7b293c43c41e07d6050c76_MD5.jpeg]]
- 现在执行客户端程序，执行结果如下：
[[assets/Web编程之网络基础/5461adb698c6f9f89d37c79bcfa01b1c_MD5.jpeg|Open: Pasted image 20240220140513.png]]
![[assets/Web编程之网络基础/5461adb698c6f9f89d37c79bcfa01b1c_MD5.jpeg]]
- 相应的服务器端执行结果，其中的客户端端口52156由客户端程序在调用sendto()时自动生成：
[[assets/Web编程之网络基础/164631d2a2568138b5e097c9c579abee_MD5.jpeg|Open: Pasted image 20240220140516.png]]
![[assets/Web编程之网络基础/164631d2a2568138b5e097c9c579abee_MD5.jpeg]]